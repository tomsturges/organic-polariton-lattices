
// ********************************************************
// simulation logging

#define _SAMPLE_LOG_LEVEL             (1 << 0)
#define _SEGMENT_LOG_LEVEL            (1 << 1)
#define _PATH_LOG_LEVEL               (1 << 2)
#define _SIMULATION_LOG_LEVEL         (1 << 3)
#define _WARNING_LOG_LEVEL            (1 << 4)
#define _ERROR_LOG_LEVEL              (1 << 5)
#define _NO_ERROR_TERMINATE_LOG_LEVEL (1 << 6)
#define _ALL_LOG_LEVELS        _SAMPLE_LOG_LEVEL|_SEGMENT_LOG_LEVEL|_PATH_LOG_LEVEL|_SIMULATION_LOG_LEVEL|_WARNING_LOG_LEVEL|_ERROR_LOG_LEVEL|_NO_ERROR_TERMINATE_LOG_LEVEL
#define _LOG_LEVELS_BEING_LOGGED (_ALL_LOG_LEVELS)

#define real Re
#define imag Im

#include <complex>

#undef real
#undef imag


#include <stdio.h>

#define _LOG(logLevel, ...) \
  do { \
    if (logLevel & _LOG_LEVELS_BEING_LOGGED) { \
      if (logLevel & (_ERROR_LOG_LEVEL | _WARNING_LOG_LEVEL)) \
          printf("%s:%i: ", __FILE__, __LINE__); \
      printf(__VA_ARGS__); \
      fflush(stdout); \
      if (logLevel & (_ERROR_LOG_LEVEL | _NO_ERROR_TERMINATE_LOG_LEVEL)) \
        exit(logLevel == _ERROR_LOG_LEVEL); \
    } \
  } while (0)

// ********************************************************
// simulation includes

#include <xpdeint_platform.h>
#include <cmath>
#include <string>
#include <cstring>
#include <fstream>
#include <sstream>
#include <cstdlib>

#if CFG_OSAPI == CFG_OSAPI_POSIX // These are POSIX headers (i.e. non-windows)
  #include <sys/time.h>
#endif // POSIX

#ifdef __APPLE__
  #include <Availability.h>
  #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
    #define OS_OBJECT_USE_OBJC 0 // Don't make dispatch and xpc objects Objective-C objects.
    #include <IOKit/pwr_mgt/IOPMLib.h> // To disable user idle sleep on Mountain Lion
  #endif
#endif

#include <time.h>
#include <list>
#include <vector>
#include <algorithm>

#include <utility>
#include <map>

#include <getopt.h>

#define H5_USE_16_API
#include <hdf5.h>

#if !defined(HAVE_H5LEXISTS)
htri_t H5Lexists(hid_t loc_id, const char *name, hid_t lapl_id)
{
  H5E_auto_t error_func;
  void* error_client_data;
  // Squelch errors generated by H5Gget_objinfo. It will report errors when it can't find an object
  // but that's the purpose of calling it.
  H5Eget_auto(&error_func, &error_client_data);
  H5Eset_auto(NULL, NULL);
  herr_t err = H5Gget_objinfo(loc_id, name, false, NULL);
  H5Eset_auto(error_func, error_client_data);
  if (err >= 0)
    return true;
  else
    return false;
}
#endif

#define H5T_NATIVE_REAL H5T_NATIVE_DOUBLE
#if defined(HAVE_HDF5_HL)
  #include <hdf5_hl.h>
#endif


typedef long integer;
typedef double real;
typedef std::complex<real> XMDSComplexType;

#include <xpdeint.h>

#define complex XMDSComplexType

const complex i(0.0, 1.0);

using namespace std;

#if CFG_COMPILER == CFG_COMPILER_ICC
  //
  // Disable ICC's warning: label was declared but never referenced
  //
  #pragma warning ( disable : 177 )
#endif

inline void *xmds_malloc(size_t size);

// ********************************************************
// DEFINES
// ********************************************************

// ********************************************************
//   Simulation defines
#define _EPSILON 1e-6
#ifndef INFINITY
#define INFINITY HUGE_VAL
#endif

#ifndef MAX
#define MAX(a, b) \
  ({ typeof(a) _a = (a); \
     typeof(b) _b = (b); \
     _a > _b ? _a : _b; })
#endif

#ifndef MIN
#define MIN(a, b) \
   ({ typeof(a) _a = (a); \
      typeof(b) _b = (b); \
      _a < _b ? _a : _b; })
#endif


// ********************************************************
//   Geometry defines
#define _lattice_m ((int)M)
#define _min_m     ((long)1)
#define _max_m     ((long)M)
#define _dm        ((long)1)

#define _lattice_n ((int)M)
#define _min_n     ((long)1)
#define _max_n     ((long)M)
#define _dn        ((long)1)

// ********************************************************
//   field mn defines
#define _mn_ndims 2


// vector variables defines
#define _mn_variables_ncomponents 3

// vector OmegaVec defines
#define _mn_OmegaVec_ncomponents 1

// vector deltaVec defines
#define _mn_deltaVec_ncomponents 1

// vector TheOmegaNoise defines
#define _mn_TheOmegaNoise_ncomponents 1

// ********************************************************
//   field m defines
#define _m_ndims 1


// vector OnSiteNoise defines
#define _m_OnSiteNoise_ncomponents 1

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) defines
// vector variables defines
#define _segment1_operator0_delta_a_field_variables_ncomponents 3

// ********************************************************
//   field mg0_sampling defines
#define _mg0_sampling_ndims 2


// ********************************************************
//   field mg0_output defines
#define _mg0_output_ndims 3


#define _mg0_output_lattice_t ((int)201)
#define _mg0_output_min_t     (_mg0_output_t[0])
#define _mg0_output_max_t     (_mg0_output_t[_mg0_output_lattice_t-1])
#define _mg0_output_dt        (_mg0_output_t[_index_t+1]-_mg0_output_t[_index_t])

// vector raw defines
#define _mg0_output_raw_ncomponents 1

// ********************************************************
//   field segment1_operator0_looping_field defines
#define _segment1_operator0_looping_field_ndims 2


// ********************************************************
//   field segment1_operator0_delta_a_field defines
#define _segment1_operator0_delta_a_field_ndims 2



// ********************************************************
// GLOBALS
// ********************************************************


// ********************************************************
//   Simulation globals

string gsArgsAndValues = "";


// gPathID is used to keep track of the current path number when doing multipath simulations.
// It's needed for the export_all_paths option. Note his counter is per rank, so when
// running the mpi-multi-path driver it runs from 0 to _n_paths / _size - 1.
long gPathID = 0;    

  
real t;

// ********************************************************
//   Transform Multiplexer globals
typedef pair<ptrdiff_t, ptrdiff_t> _basis_pair;
typedef void (*transform_function)(bool, real, real* const __restrict__, real* const __restrict__, ptrdiff_t, ptrdiff_t);

// Less than operator needed by the C++ map class
struct _basis_pair_less_than
{
  bool operator()(const _basis_pair& _x, const _basis_pair& _y) const {
    return (_x.first < _y.first) || ((_x.first == _y.first) && (_x.second < _y.second));
  }
};

struct _transform_step
{
  transform_function _func;
  bool _forward;
  bool _out_of_place;
  ptrdiff_t _prefix_lattice;
  ptrdiff_t _postfix_lattice;
};

// Structure to hold the basis change information
struct _basis_transform_t
{
  vector<_transform_step> _transform_steps;
  real _multiplier;
  
  _basis_transform_t(real _multiplier_in = 1.0) : _multiplier(_multiplier_in) {}
  
  _basis_transform_t(const _basis_transform_t& _b) : _transform_steps(_b._transform_steps), _multiplier(_b._multiplier) {}
  
  void append(transform_function _func, bool _forward, bool _out_of_place, ptrdiff_t _prefix_lattice, ptrdiff_t _postfix_lattice)
  {
    _transform_steps.push_back((_transform_step){_func, _forward, _out_of_place, _prefix_lattice, _postfix_lattice});
  }
};

// Map type for holding (old_basis, new_basis) -> _basis_transform_t mappings
typedef map<_basis_pair, _basis_transform_t, _basis_pair_less_than> _basis_map;


real *_auxiliary_array = NULL;

const char *_basis_identifiers[] = {
};

// ********************************************************
//   'Globals' element globals

#line 9 "org-pol-lat.xmds"

real Kron(int m, int n) {
  return (m == n) ? 1 : 0;
}

#line 292 "org-pol-lat.cc"

// ********************************************************
//   Command line argument processing globals
real gammaR = 0.7; 
real gammaC = 4; 
real gammaV = 2.9; 
real P0 = 30.; 
real g = 0.5; 
real omegaR = 2720; 
real omegaC = 2526; 
real omegaV = 194; 
real Omega0 = 33; 
real OmegaDiff = 7; 
int M = 40; 
real sigmaOmega = 0 * Omega0; 
real sigmadelta = 0* Omega0; 
real Gamma = gammaR + gammaC + gammaV; 
real hbar = 0.6582; 

// ********************************************************
//   Geometry globals
long* _m = NULL;

long* _n = NULL;

// ********************************************************
//   field mn globals
// vector variables globals
size_t _mn_variables_alloc_size = 0;
complex* _mn_variables = NULL;
complex* _active_mn_variables = NULL;

// vector OmegaVec globals
size_t _mn_OmegaVec_alloc_size = 0;
real* _mn_OmegaVec = NULL;
real* _active_mn_OmegaVec = NULL;

// vector deltaVec globals
size_t _mn_deltaVec_alloc_size = 0;
real* _mn_deltaVec = NULL;
real* _active_mn_deltaVec = NULL;

// vector TheOmegaNoise globals
size_t _mn_TheOmegaNoise_alloc_size = 0;
real* _mn_TheOmegaNoise = NULL;
real* _active_mn_TheOmegaNoise = NULL;

uint32_t _gen_TheOmegaNoise_seeds[10];
unsigned short _gen_TheOmegaNoise[3];

// ********************************************************
//   field m globals
// vector OnSiteNoise globals
size_t _m_OnSiteNoise_alloc_size = 0;
real* _m_OnSiteNoise = NULL;
real* _active_m_OnSiteNoise = NULL;

uint32_t _gen_OnSiteNoise_seeds[10];
unsigned short _gen_OnSiteNoise[3];

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) globals
complex* _segment1_akfield_mn_variables;
complex* _segment1_aifield_mn_variables;

// vector variables globals
size_t _segment1_operator0_delta_a_field_variables_alloc_size = 0;
complex* _segment1_operator0_delta_a_field_variables = NULL;
complex* _active_segment1_operator0_delta_a_field_variables = NULL;

// ********************************************************
//   field mg0_output globals
real* _mg0_output_t = NULL;
unsigned long _mg0_output_index_t = 0;

// vector raw globals
size_t _mg0_output_raw_alloc_size = 0;
real* _mg0_output_raw = NULL;
real* _active_mg0_output_raw = NULL;


// ********************************************************
// FUNCTION PROTOTYPES
// ********************************************************

// ********************************************************
//   Command line argument processing function prototypes
void _print_usage();

// ********************************************************
//   field mn function prototypes
void _mn_variables_initialise();

void _mn_OmegaVec_initialise();

void _mn_deltaVec_initialise();

void _mn_TheOmegaNoise_evaluate();

// ********************************************************
//   field m function prototypes
void _m_OnSiteNoise_evaluate();

// ********************************************************
//   segment 0 (Top level sequence) function prototypes
void _segment0();

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function prototypes
void _segment1();
inline void _segment1_calculate_delta_a(real _step);
inline void _segment1_ip_evolve(int _exponent);
inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent);

void _segment1_mn_operators_evaluate_operator0(real _step);
inline void _segment1_mn_operators_operator0_copy_delta_a(real _step);

// ********************************************************
//   output function prototypes
void _write_output();

FILE* _open_xsil_file(const char* _filename);
void _close_xsil_file(FILE*& fp);
void _write_xsil_header(FILE* fp);
void _write_xsil_footer(FILE* fp);

// ********************************************************
//   moment group 0 function prototypes
void _mg0_sample();
void _mg0_process();
void _mg0_write_out(FILE* _outfile);

// ********************************************************
//   field mg0_output function prototypes
void _mg0_output_raw_initialise();

// ********************************************************
// MAIN ROUTINE
// ********************************************************
int main(int argc, char **argv)
{
  #ifdef __APPLE__
    #if __MAC_OS_X_VERSION_MIN_REQUIRED >= 1080
  {
    IOPMAssertionID _powerAssertionID = 0;
    IOReturn __io_result = IOPMAssertionCreateWithDescription(
      kIOPMAssertionTypePreventUserIdleSystemSleep,
      CFSTR("XMDS simulation 'org-pol-lat' preventing user idle sleep"), // Assertion name
      NULL, // Assertion details
      NULL, // Human-readable reason
      NULL, // Localization bundle path
      (CFTimeInterval)0, // never timeout
      kIOPMAssertionTimeoutActionRelease,
      &_powerAssertionID
      );
    if (__io_result != kIOReturnSuccess) {
      _LOG(_WARNING_LOG_LEVEL, "Failed to disable user idle sleep\n");
    }
    // Note, this power assertion is automatically released when the process quits.
  }
    #endif
  #endif
  
    
  // *********** Parse the command line for arguments, and set  *********
  // *********** the appropriate global variables               *********
  
  int resp;
  std::map<string, string> mInputArgsAndValues;
  
  while (1) {
    static struct option long_options[] = 
      {
        {"help", no_argument, 0, 'h'},
        {"gammaR", required_argument, 0, 'g'},
        {"gammaC", required_argument, 0, 'a'},
        {"gammaV", required_argument, 0, 'm'},
        {"P0", required_argument, 0, 'P'},
        {"g", required_argument, 0, 'b'},
        {"omegaR", required_argument, 0, 'o'},
        {"omegaC", required_argument, 0, 'e'},
        {"omegaV", required_argument, 0, 'V'},
        {"Omega0", required_argument, 0, 'O'},
        {"OmegaDiff", required_argument, 0, 'D'},
        {"M", required_argument, 0, 'M'},
        {"sigmaOmega", required_argument, 0, 's'},
        {"sigmadelta", required_argument, 0, 'i'},
        {"Gamma", required_argument, 0, 'G'},
        {"hbar", required_argument, 0, 'r'},
        {NULL, 0, 0, 0}
      };
    
    int option_index = 0;
  
    resp = getopt_long(argc, argv, "hg:a:m:P:b:o:e:V:O:D:M:s:i:G:r:", long_options, &option_index);
    
    if (resp == -1)
      break;
  
    switch (resp) {
      case '?':
        // An unknown option was passed. Show allowed options and exit. 
        _print_usage(); // This causes the simulation to exit
  
      case 'h':
        _print_usage(); // This causes the simulation to exit
      
      case 'g':
        gammaR = strtod(optarg, NULL);
        break;
      
      case 'a':
        gammaC = strtod(optarg, NULL);
        break;
      
      case 'm':
        gammaV = strtod(optarg, NULL);
        break;
      
      case 'P':
        P0 = strtod(optarg, NULL);
        break;
      
      case 'b':
        g = strtod(optarg, NULL);
        break;
      
      case 'o':
        omegaR = strtod(optarg, NULL);
        break;
      
      case 'e':
        omegaC = strtod(optarg, NULL);
        break;
      
      case 'V':
        omegaV = strtod(optarg, NULL);
        break;
      
      case 'O':
        Omega0 = strtod(optarg, NULL);
        break;
      
      case 'D':
        OmegaDiff = strtod(optarg, NULL);
        break;
      
      case 'M':
        M = strtol(optarg, NULL, 10);
        break;
      
      case 's':
        sigmaOmega = strtod(optarg, NULL);
        break;
      
      case 'i':
        sigmadelta = strtod(optarg, NULL);
        break;
      
      case 'G':
        Gamma = strtod(optarg, NULL);
        break;
      
      case 'r':
        hbar = strtod(optarg, NULL);
        break;
        
      default:
        _LOG(_ERROR_LOG_LEVEL, "Internal error in processing arguments.\n");
    }
  }
  
  
  if (optind < argc)
    _print_usage(); // This causes the simulation to exit.
  
  // ******** Argument post-processing code *******
  // **********************************************
  
    
  
  _mn_deltaVec_alloc_size = MAX(_mn_deltaVec_alloc_size, (_lattice_m * _lattice_n) * _mn_deltaVec_ncomponents);
  _mn_OmegaVec_alloc_size = MAX(_mn_OmegaVec_alloc_size, (_lattice_m * _lattice_n) * _mn_OmegaVec_ncomponents);
  _mn_TheOmegaNoise_alloc_size = MAX(_mn_TheOmegaNoise_alloc_size, (_lattice_m * _lattice_n) * _mn_TheOmegaNoise_ncomponents);
  _mn_variables_alloc_size = MAX(_mn_variables_alloc_size, (_lattice_m * _lattice_n) * _mn_variables_ncomponents);
  _m_OnSiteNoise_alloc_size = MAX(_m_OnSiteNoise_alloc_size, (_lattice_m) * _m_OnSiteNoise_ncomponents);
  _segment1_operator0_delta_a_field_variables_alloc_size = MAX(_segment1_operator0_delta_a_field_variables_alloc_size, (_lattice_m * _lattice_n) * _segment1_operator0_delta_a_field_variables_ncomponents);
  _mg0_output_raw_alloc_size = MAX(_mg0_output_raw_alloc_size, (_mg0_output_lattice_t * _lattice_m * _lattice_n) * _mg0_output_raw_ncomponents);
  _m = (long*) xmds_malloc(sizeof(long) * (_lattice_m+1));
  
  _n = (long*) xmds_malloc(sizeof(long) * (_lattice_n+1));
  
  _mn_variables = (complex*) xmds_malloc(sizeof(complex) * MAX(_mn_variables_alloc_size,1));
  _active_mn_variables = _mn_variables;
  
  
  _mn_OmegaVec = (real*) xmds_malloc(sizeof(real) * MAX(_mn_OmegaVec_alloc_size,1));
  _active_mn_OmegaVec = _mn_OmegaVec;
  
  
  _mn_deltaVec = (real*) xmds_malloc(sizeof(real) * MAX(_mn_deltaVec_alloc_size,1));
  _active_mn_deltaVec = _mn_deltaVec;
  
  
  _mn_TheOmegaNoise = (real*) xmds_malloc(sizeof(real) * MAX(_mn_TheOmegaNoise_alloc_size,1));
  _active_mn_TheOmegaNoise = _mn_TheOmegaNoise;
  
  _m_OnSiteNoise = (real*) xmds_malloc(sizeof(real) * MAX(_m_OnSiteNoise_alloc_size,1));
  _active_m_OnSiteNoise = _m_OnSiteNoise;
  _mg0_output_t = (real*) xmds_malloc(sizeof(real) * (_mg0_output_lattice_t+1));
  
  
  _mg0_output_raw = (real*) xmds_malloc(sizeof(real) * MAX(_mg0_output_raw_alloc_size,1));
  _active_mg0_output_raw = _mg0_output_raw;
  
  
  // Run-time validation checks
  
  if (1 >= M)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'M' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)1, (real)M);
  
  if ((M) != ((M) - (1) + 1))
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The lattice value of 'M'=%li doesn't match with the domain "
                           "'1'=%li to 'M'=%li (%li lattice points).\n",
                           long(M), long(1), long(M), long((M) - (1)+1));
  
  
  if (1 >= M)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The end point of the dimension 'M' must be "
                           "greater than the start point.\n"
                           "Start = %e, End = %e\n", (real)1, (real)M);
  
  if ((M) != ((M) - (1) + 1))
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The lattice value of 'M'=%li doesn't match with the domain "
                           "'1'=%li to 'M'=%li (%li lattice points).\n",
                           long(M), long(1), long(M), long((M) - (1)+1));
  
  
  if (M > M)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Can't sample more points in dimension 'm' than\n"
                           "there are points in the full dimension.\n"
                           "%i > %i.\n", (int)M, (int)M);
  
  if ( (M > 0) && (M % M !=0) )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The number of sampling lattice points (%i) must divide the number\n"
                         "of lattice points on the simulation grid (%i).\n", (int)M, (int)M);
  
  
  if (M > M)
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Can't sample more points in dimension 'n' than\n"
                           "there are points in the full dimension.\n"
                           "%i > %i.\n", (int)M, (int)M);
  
  if ( (M > 0) && (M % M !=0) )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: The number of sampling lattice points (%i) must divide the number\n"
                         "of lattice points on the simulation grid (%i).\n", (int)M, (int)M);
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++)
    _m[_index_m] = _min_m + _index_m*_dm;
  for (long _index_n = 0; _index_n < _lattice_n; _index_n++)
    _n[_index_n] = _min_n + _index_n*_dn;
  _active_mg0_output_raw = _mg0_output_raw;
  _mg0_output_raw_initialise();
  
  #if HAVE_DEV_URANDOM
    uint32_t __seeds_gen_TheOmegaNoise[10];
    FILE *__urandom_fp_gen_TheOmegaNoise = fopen("/dev/urandom", "r");
  
    if (__urandom_fp_gen_TheOmegaNoise == NULL) {
        _LOG(_ERROR_LOG_LEVEL, "Unable to seed random number generator from /dev/urandom.  Is it accessible?\n");
        // Implicit quit
    }
  
    size_t __entries_read_gen_TheOmegaNoise = 0;
    __entries_read_gen_TheOmegaNoise = fread(__seeds_gen_TheOmegaNoise, sizeof(uint32_t), 10, __urandom_fp_gen_TheOmegaNoise);
  
    if (__entries_read_gen_TheOmegaNoise != 10) {
      _LOG(_ERROR_LOG_LEVEL, "Unable to read from /dev/urandom while seeding the random number generator.\n");
        // Implicit quit
    }
  
    fclose(__urandom_fp_gen_TheOmegaNoise);
  
    for (unsigned long _i0=0; _i0 < 10; _i0++) {
      _gen_TheOmegaNoise_seeds[_i0] = (uint32_t) __seeds_gen_TheOmegaNoise[_i0];
    }
  
  #else
  #error Do not have a run-time random number source! Please supply seeds manually.
  #endif
  
  #if HAVE_DEV_URANDOM
    uint32_t __seeds_gen_OnSiteNoise[10];
    FILE *__urandom_fp_gen_OnSiteNoise = fopen("/dev/urandom", "r");
  
    if (__urandom_fp_gen_OnSiteNoise == NULL) {
        _LOG(_ERROR_LOG_LEVEL, "Unable to seed random number generator from /dev/urandom.  Is it accessible?\n");
        // Implicit quit
    }
  
    size_t __entries_read_gen_OnSiteNoise = 0;
    __entries_read_gen_OnSiteNoise = fread(__seeds_gen_OnSiteNoise, sizeof(uint32_t), 10, __urandom_fp_gen_OnSiteNoise);
  
    if (__entries_read_gen_OnSiteNoise != 10) {
      _LOG(_ERROR_LOG_LEVEL, "Unable to read from /dev/urandom while seeding the random number generator.\n");
        // Implicit quit
    }
  
    fclose(__urandom_fp_gen_OnSiteNoise);
  
    for (unsigned long _i0=0; _i0 < 10; _i0++) {
      _gen_OnSiteNoise_seeds[_i0] = (uint32_t) __seeds_gen_OnSiteNoise[_i0];
    }
  
  #else
  #error Do not have a run-time random number source! Please supply seeds manually.
  #endif
  
  
  _basis_transform_t *_basis_transform = NULL;
  ptrdiff_t _auxiliary_array_size = 0;
  ptrdiff_t _max_vector_size = 0;
  real* _max_vector_array = NULL;
  
  if (_auxiliary_array_size) {
    _auxiliary_array = (real*) xmds_malloc(sizeof(real) * _auxiliary_array_size);
  }
  
  bool _allocated_temporary_array = false;
  if (!_max_vector_array && _max_vector_size > 0) {
    _max_vector_array = (real*) xmds_malloc(sizeof(real) * _max_vector_size);
    _allocated_temporary_array = true;
  }
  
  // Make all geometry-dependent transformations prepare plans, etc.
  
  if (_allocated_temporary_array) {
    xmds_free(_max_vector_array);
  }
  
  /* Code that actually does stuff goes here */
  _segment0();
  
  
  _write_output();
  if (_auxiliary_array) {
    xmds_free(_auxiliary_array);
  }
  
  xmds_free(_mn_variables);
  _active_mn_variables = _mn_variables = NULL;
  
  
  xmds_free(_mn_OmegaVec);
  _active_mn_OmegaVec = _mn_OmegaVec = NULL;
  
  
  xmds_free(_mn_deltaVec);
  _active_mn_deltaVec = _mn_deltaVec = NULL;
  
  
  xmds_free(_mn_TheOmegaNoise);
  _active_mn_TheOmegaNoise = _mn_TheOmegaNoise = NULL;
  
  xmds_free(_m_OnSiteNoise);
  _active_m_OnSiteNoise = _m_OnSiteNoise = NULL;
  
  xmds_free(_mg0_output_raw);
  _active_mg0_output_raw = _mg0_output_raw = NULL;
  
  
  return 0;
}

// ********************************************************
// FUNCTION IMPLEMENTATIONS
// ********************************************************

inline void *xmds_malloc(size_t size)
{
  void *retPointer = _xmds_malloc(size);
  if ( !retPointer )
    _LOG(_ERROR_LOG_LEVEL, "ERROR: Couldn't allocate %zu bytes of memory!", size);
  return retPointer;
}


// ********************************************************
//   Command line argument processing function implementations
void _print_usage()
{
  // This function does not return.
  _LOG(_NO_ERROR_TERMINATE_LOG_LEVEL, "\n\nUsage: org-pol-lat --gammaR <real> --gammaC <real> --gammaV <real> --P0 <real> --g <real> --omegaR <real> --omegaC <real> --omegaV <real> --Omega0 <real> --OmegaDiff <real> --M <int> --sigmaOmega <real> --sigmadelta <real> --Gamma <real> --hbar <real>\n\n"
                         "Details:\n"
                         "Option\t\tType\t\tDefault value\n"
                         "-g,  --gammaR\treal \t\t0.7\n"
                         "-a,  --gammaC\treal \t\t4\n"
                         "-m,  --gammaV\treal \t\t2.9\n"
                         "-P,  --P0\treal \t\t30.\n"
                         "-b,  --g\treal \t\t0.5\n"
                         "-o,  --omegaR\treal \t\t2720\n"
                         "-e,  --omegaC\treal \t\t2526\n"
                         "-V,  --omegaV\treal \t\t194\n"
                         "-O,  --Omega0\treal \t\t33\n"
                         "-D,  --OmegaDiff\treal \t\t7\n"
                         "-M,  --M\tint \t\t40\n"
                         "-s,  --sigmaOmega\treal \t\t0 * Omega0\n"
                         "-i,  --sigmadelta\treal \t\t0* Omega0\n"
                         "-G,  --Gamma\treal \t\tgammaR + gammaC + gammaV\n"
                         "-r,  --hbar\treal \t\t0.6582\n"
                         );
  // _LOG terminates the simulation.
}

// ********************************************************
//   Default Simulation Driver function implementations
void _segment0()
{
  
  
  uint32_t _gen_TheOmegaNoise_local_seeds[10] = {
  _gen_TheOmegaNoise_seeds[0]+(0)*1,
  _gen_TheOmegaNoise_seeds[1]+(0)*2,
  _gen_TheOmegaNoise_seeds[2]+(0)*3,
  _gen_TheOmegaNoise_seeds[3]+(0)*4,
  _gen_TheOmegaNoise_seeds[4]+(0)*5,
  _gen_TheOmegaNoise_seeds[5]+(0)*6,
  _gen_TheOmegaNoise_seeds[6]+(0)*7,
  _gen_TheOmegaNoise_seeds[7]+(0)*8,
  _gen_TheOmegaNoise_seeds[8]+(0)*9,
  _gen_TheOmegaNoise_seeds[9]+(0)*10
  };
  
  
  bzero(_gen_TheOmegaNoise, sizeof(_gen_TheOmegaNoise));
  for (unsigned long _i0=0; _i0<MIN(3, 10); _i0++)
    _gen_TheOmegaNoise[_i0] = (unsigned short)_gen_TheOmegaNoise_local_seeds[_i0];
  
  erand48(_gen_TheOmegaNoise);
  
  
  
  uint32_t _gen_OnSiteNoise_local_seeds[10] = {
  _gen_OnSiteNoise_seeds[0]+(0)*1,
  _gen_OnSiteNoise_seeds[1]+(0)*2,
  _gen_OnSiteNoise_seeds[2]+(0)*3,
  _gen_OnSiteNoise_seeds[3]+(0)*4,
  _gen_OnSiteNoise_seeds[4]+(0)*5,
  _gen_OnSiteNoise_seeds[5]+(0)*6,
  _gen_OnSiteNoise_seeds[6]+(0)*7,
  _gen_OnSiteNoise_seeds[7]+(0)*8,
  _gen_OnSiteNoise_seeds[8]+(0)*9,
  _gen_OnSiteNoise_seeds[9]+(0)*10
  };
  
  
  bzero(_gen_OnSiteNoise, sizeof(_gen_OnSiteNoise));
  for (unsigned long _i0=0; _i0<MIN(3, 10); _i0++)
    _gen_OnSiteNoise[_i0] = (unsigned short)_gen_OnSiteNoise_local_seeds[_i0];
  
  erand48(_gen_OnSiteNoise);
  
  t = 0.0;
  
  _mg0_output_raw_initialise();
  _active_mn_variables = _mn_variables;
  _mn_variables_initialise();
  _mn_TheOmegaNoise_evaluate();
  _active_mn_OmegaVec = _mn_OmegaVec;
  _mn_OmegaVec_initialise();
  _m_OnSiteNoise_evaluate();
  _active_mn_deltaVec = _mn_deltaVec;
  _mn_deltaVec_initialise();
  _mg0_output_index_t = 0;
  _mg0_sample();
  _segment1();
  
  _mg0_process();
}


// ********************************************************
//   field mn function implementations
// initialisation for vector variables
void _mn_variables_initialise()
{
  
  long _mn_variables_index_pointer = 0;
  #define rho _active_mn_variables[_mn_variables_index_pointer + 0]
  #define NR _active_mn_variables[_mn_variables_index_pointer + 1]
  #define J _active_mn_variables[_mn_variables_index_pointer + 2]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #line 47 "org-pol-lat.xmds"
      
      rho = 0.;
      NR = 0.;
      J = 0.;
      
      #line 907 "org-pol-lat.cc"
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field mn (or having the same dimensions)
      _mn_variables_index_pointer += 1 * _mn_variables_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  #undef rho
  #undef NR
  #undef J
}

// initialisation for vector OmegaVec
void _mn_OmegaVec_initialise()
{
  
  long _mn_OmegaVec_index_pointer = 0;
  #define Omega _active_mn_OmegaVec[_mn_OmegaVec_index_pointer + 0]
  long _mn_TheOmegaNoise_index_pointer = 0;
  #define OmegaNoise _active_mn_TheOmegaNoise[_mn_TheOmegaNoise_index_pointer + 0]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #define _OmegaNoise_mn(_index_m, _index_n) _active_mn_TheOmegaNoise[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_TheOmegaNoise_ncomponents]
      #line 69 "org-pol-lat.xmds"
      
      Omega = (abs(m - n) == 1) ? Omega0 - OmegaDiff * pow(-1, max(m,n)) + (sigmaOmega / sqrt(2)) * (OmegaNoise + _OmegaNoise_mn(/* m => n */ ((n) - _min_m), /* n => m */ ((m) - _min_n))): 0;
      
      #line 955 "org-pol-lat.cc"
      #undef _OmegaNoise_mn
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field mn (or having the same dimensions)
      _mn_OmegaVec_index_pointer += 1 * _mn_OmegaVec_ncomponents;
      _mn_TheOmegaNoise_index_pointer += 1 * _mn_TheOmegaNoise_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  #undef Omega
  #undef OmegaNoise
}

// initialisation for vector deltaVec
void _mn_deltaVec_initialise()
{
  
  long _m_OnSiteNoise_index_pointer = 0;
  #define onsiteNoise _active_m_OnSiteNoise[_m_OnSiteNoise_index_pointer + 0]
  long _mn_deltaVec_index_pointer = 0;
  #define delta _active_mn_deltaVec[_mn_deltaVec_index_pointer + 0]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      // Set index pointers explicitly for (some) vectors
      _m_OnSiteNoise_index_pointer = ( 0
         + _index_m * 1 ) * _m_OnSiteNoise_ncomponents;
      // The purpose of the following define is to give a (somewhat helpful) compile-time error
      // if the user has attempted to use the propagation dimension variable in the initialisation
      // block of a <vector> element. If they're trying to do this, what they really want is a 
      // <computed_vector> instead.
      #define t Dont_use_propagation_dimension_t_in_vector_element_CDATA_block___Use_a_computed_vector_instead
      
      // ********** Initialisation code ***************
      #line 81 "org-pol-lat.xmds"
      
      delta = omegaR - (omegaC + sigmadelta * onsiteNoise + omegaV);
      
      #line 1004 "org-pol-lat.cc"
      // **********************************************
      #undef t
      
      // Increment index pointers for vectors in field mn (or having the same dimensions)
      _mn_deltaVec_index_pointer += 1 * _mn_deltaVec_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  #undef onsiteNoise
  #undef delta
}

void _mn_TheOmegaNoise_evaluate()
{
  const ptrdiff_t _vector_size = (_lattice_m * _lattice_n) * _mn_TheOmegaNoise_ncomponents;
  const real _var = 1.0 / (1.0);
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = 2.0*erand48(_gen_TheOmegaNoise) - 1.0;
      _v2 = 2.0*erand48(_gen_TheOmegaNoise) - 1.0;
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_mn_TheOmegaNoise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_mn_TheOmegaNoise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_mn_TheOmegaNoise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = 2.0*erand48(_gen_TheOmegaNoise) - 1.0;
        _v2 = 2.0*erand48(_gen_TheOmegaNoise) - 1.0;
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_mn_TheOmegaNoise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
}

// ********************************************************
//   field m function implementations
void _m_OnSiteNoise_evaluate()
{
  const ptrdiff_t _vector_size = (_lattice_m) * _m_OnSiteNoise_ncomponents;
  const real _var = 1.0 / (1.0);
  
  const ptrdiff_t _evenNoises = _vector_size & ~1;
  for (ptrdiff_t _i0 = 0; _i0 < _evenNoises; _i0 += 2) {
    real _v1, _v2, _rsq;
    do {
      _v1 = 2.0*erand48(_gen_OnSiteNoise) - 1.0;
      _v2 = 2.0*erand48(_gen_OnSiteNoise) - 1.0;
      _rsq = _v1*_v1 + _v2*_v2;
    } while(_rsq >= 1.0 || _rsq == 0.0);
    const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
    reinterpret_cast<real*>(_active_m_OnSiteNoise)[_i0 + 0] = _v1*_fac;
    reinterpret_cast<real*>(_active_m_OnSiteNoise)[_i0 + 1] = _v2*_fac;
  }
  
  // If _n is odd, we need to generate the last random number
  if (_vector_size & 1) {
    static real _spareNoise = 0.0;
    static bool _spareNoiseAvailable = false;
    static real _old_var = 0.0;
    
    if (_spareNoiseAvailable && _old_var == _var) {
      reinterpret_cast<real*>(_active_m_OnSiteNoise)[_vector_size - 1] = _spareNoise;
      _spareNoiseAvailable = false;
    } else {
      real _v1, _v2, _rsq;
      do {
        _v1 = 2.0*erand48(_gen_OnSiteNoise) - 1.0;
        _v2 = 2.0*erand48(_gen_OnSiteNoise) - 1.0;
        _rsq = _v1*_v1 + _v2*_v2;
      } while(_rsq >= 1.0 || _rsq == 0.0);
      const real _fac = sqrt(-2.0*_var*log(_rsq)/_rsq);
      reinterpret_cast<real*>(_active_m_OnSiteNoise)[_vector_size - 1] = _v1*_fac;
      _spareNoise = _v2*_fac;
      
      _spareNoiseAvailable = true;
      _old_var = _var;
    }
  }
}

// ********************************************************
//   segment 1 (RK4 fixed-step integrator) function implementations
void _segment1()
{
  real _step = 5/(real)50000;
  real _noiseStep = 5/(real)50000;
  
  
  _segment1_operator0_delta_a_field_variables = (complex*) xmds_malloc(sizeof(complex) * MAX(_segment1_operator0_delta_a_field_variables_alloc_size,1));
  _active_segment1_operator0_delta_a_field_variables = _segment1_operator0_delta_a_field_variables;
  _segment1_akfield_mn_variables = (complex*) xmds_malloc(sizeof(complex) * MAX(_mn_variables_alloc_size,1));
  _segment1_aifield_mn_variables = (complex*) xmds_malloc(sizeof(complex) * MAX(_mn_variables_alloc_size,1));
  complex* _akfield_mn_variables = _segment1_akfield_mn_variables;
  complex* _aifield_mn_variables = _segment1_aifield_mn_variables;
  
  
  for (long _istep = 0; _istep < 50000; _istep++) {
    
    
    // a_k = a
    memcpy(_akfield_mn_variables, _mn_variables, sizeof(complex) * _mn_variables_alloc_size);
    
    _segment1_calculate_nonconstant_ip_fields(_step, 1);
    
    // a = D[a]
    _segment1_ip_evolve(1);
    
    // a_i = a
    memcpy(_aifield_mn_variables, _mn_variables, sizeof(complex) * _mn_variables_alloc_size);
    
    _active_mn_variables = _akfield_mn_variables;
      
    // a_k = G[a_k, t]
    _segment1_calculate_delta_a(_step);
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    
    for (long _i0 = 0; _i0 < (_lattice_m * _lattice_n) * _mn_variables_ncomponents; _i0++) {
      // a = a + a_k/6
      _mn_variables[_i0] += _akfield_mn_variables[_i0]/6.0;
      // a_k = a_i + a_k/2
      _akfield_mn_variables[_i0] = _aifield_mn_variables[_i0] + 0.5*_akfield_mn_variables[_i0];
    }
    
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    
    for (long _i0 = 0; _i0 < (_lattice_m * _lattice_n) * _mn_variables_ncomponents; _i0++) {
      // a = a + a_k/3
      _mn_variables[_i0] += _akfield_mn_variables[_i0]/3.0;
      // a_k = a_i + a_k/2
      _akfield_mn_variables[_i0] = _aifield_mn_variables[_i0] + 0.5*_akfield_mn_variables[_i0];
    }
    
    
    // a_k = G[a_k, t + h/2]
    _segment1_calculate_delta_a(_step);
    
    for (long _i0 = 0; _i0 < (_lattice_m * _lattice_n) * _mn_variables_ncomponents; _i0++) {
      // a = a + a_k/3
      _mn_variables[_i0] += _akfield_mn_variables[_i0]/3.0;
      // a_k = a_i + a_k
      _akfield_mn_variables[_i0] = _aifield_mn_variables[_i0] + _akfield_mn_variables[_i0];
    }
    
    
    // a_k = D[a_k]
    _segment1_ip_evolve(1);
    
    t += 0.5*_step;
    
    // a_k = G[a_k, t + h]
    _segment1_calculate_delta_a(_step);
    
    _active_mn_variables = _mn_variables;
    
    // a = D[a]
    _segment1_ip_evolve(1);
    
    for (long _i0 = 0; _i0 < (_lattice_m * _lattice_n) * _mn_variables_ncomponents; _i0++) {
      // a = a + a_k/6
      _mn_variables[_i0] += _akfield_mn_variables[_i0]/6.0;
    }
    
    
    if ((_istep % 250) == 249.0)
      _mg0_sample();
  }
  
  _SEGMENT1_END:;
  
  xmds_free(_segment1_operator0_delta_a_field_variables);
  _active_segment1_operator0_delta_a_field_variables = _segment1_operator0_delta_a_field_variables = NULL;
  xmds_free(_segment1_akfield_mn_variables);
  xmds_free(_segment1_aifield_mn_variables);
  
}


inline void _segment1_calculate_delta_a(real _step)
{
  
  
  // Delta A propagation operator for field mn
  _segment1_mn_operators_evaluate_operator0(_step);
  
}


inline void _segment1_ip_evolve(int _exponent)
{
}


inline void _segment1_calculate_nonconstant_ip_fields(real _step, int _exponent)
{
}

// Delta A propagation operator for field mn
void _segment1_mn_operators_evaluate_operator0(real _step)
{
  long _mn_deltaVec_index_pointer = 0;
  #define delta _active_mn_deltaVec[_mn_deltaVec_index_pointer + 0]
  long _mn_OmegaVec_index_pointer = 0;
  #define Omega _active_mn_OmegaVec[_mn_OmegaVec_index_pointer + 0]
  long _segment1_operator0_delta_a_field_variables_index_pointer = 0;
  #define drho_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 0]
  #define dNR_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 1]
  #define dJ_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 2]
  long _mn_variables_index_pointer = 0;
  #define rho _active_mn_variables[_mn_variables_index_pointer + 0]
  #define NR _active_mn_variables[_mn_variables_index_pointer + 1]
  #define J _active_mn_variables[_mn_variables_index_pointer + 2]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      
      #define dt _step
      
      // ************* Propagation code ***************
      #define _delta_m(_index_m) _active_mn_deltaVec[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_deltaVec_ncomponents]
      #define _J_n(_index_n) _active_mn_variables[2 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_variables_ncomponents]
      #define _rho_n(_index_n) _active_mn_variables[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_variables_ncomponents]
      #define _rho_mn(_index_m, _index_n) _active_mn_variables[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_variables_ncomponents]
      #define _Omega_mn(_index_m, _index_n) _active_mn_OmegaVec[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_OmegaVec_ncomponents]
      #define _Omega_n(_index_n) _active_mn_OmegaVec[0 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_OmegaVec_ncomponents]
      #define _NR_m(_index_m) _active_mn_variables[1 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_variables_ncomponents]
      #define _J_mn(_index_m, _index_n) _active_mn_variables[2 + (0 \
         + _index_m * _lattice_n \
         + _index_n * 1) * _mn_variables_ncomponents]
      #line 92 "org-pol-lat.xmds"
      
      complex sum1 = 0.;
      complex sum2 = 0.;
      complex rhomn = rho;
      complex rhonm = _rho_mn(/* m => n */ ((n) - _min_m), /* n => m */ ((m) - _min_n));
      complex rhomm = _rho_n(/* n => m */ ((m) - _min_n));
      complex Jmn = J;
      complex Jnm = _J_mn(/* m => n */ ((n) - _min_m), /* n => m */ ((m) - _min_n));
      complex Jmm = _J_n(/* n => m */ ((m) - _min_n));
      complex NRm = NR;
      complex NRn = _NR_m(/* m => n */ ((n) - _min_m));
      real pump = (m == M / 2) ? P0 : 0;
      for (int i = 1; i <= M; ++i) {
        real Omi = _Omega_n(/* n => i */ ((i) - _min_n));
        real Oni = _Omega_mn(/* m => n */ ((n) - _min_m), /* n => i */ ((i) - _min_n));
        sum1 += Omi * conj(_rho_mn(/* m => n */ ((n) - _min_m), /* n => i */ ((i) - _min_n))) - Oni * _rho_n(/* n => i */ ((i) - _min_n));
        sum2 += Oni * _J_n(/* n => i */ ((i) - _min_n));
      }
      drho_dt = (1 / hbar) * (-gammaC * rhomn + i * g * (conj(Jmn) - Jnm) + i * sum1);
      dNR_dt = (1 / hbar) * (-gammaR * NRm + pump - i * g * (conj(Jmm) - Jmm));
      dJ_dt = (1 / hbar) * (-(i * _delta_m(/* m => n */ ((n) - _min_m)) + Gamma / 2) * Jmn + i * g * NRm * (Kron(m,n) + rhonm) + i * sum2);
      
      #line 1307 "org-pol-lat.cc"
      #undef _delta_m
      #undef _J_n
      #undef _rho_n
      #undef _rho_mn
      #undef _Omega_mn
      #undef _Omega_n
      #undef _NR_m
      #undef _J_mn
      // **********************************************
      
      #undef dt
      
      
      // Increment index pointers for vectors in field segment1_operator0_looping_field (or having the same dimensions)
      _mn_deltaVec_index_pointer += 1 * _mn_deltaVec_ncomponents;
      _mn_OmegaVec_index_pointer += 1 * _mn_OmegaVec_ncomponents;
      _segment1_operator0_delta_a_field_variables_index_pointer += 1 * _segment1_operator0_delta_a_field_variables_ncomponents;
      _mn_variables_index_pointer += 1 * _mn_variables_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  _segment1_mn_operators_operator0_copy_delta_a(_step);
  #undef delta
  #undef Omega
  #undef drho_dt
  #undef dNR_dt
  #undef dJ_dt
  #undef rho
  #undef NR
  #undef J
}


inline void _segment1_mn_operators_operator0_copy_delta_a(real _step)
{
  long _mn_variables_index_pointer = 0;
  #define rho _active_mn_variables[_mn_variables_index_pointer + 0]
  #define NR _active_mn_variables[_mn_variables_index_pointer + 1]
  #define J _active_mn_variables[_mn_variables_index_pointer + 2]
  long _segment1_operator0_delta_a_field_variables_index_pointer = 0;
  #define drho_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 0]
  #define dNR_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 1]
  #define dJ_dt _active_segment1_operator0_delta_a_field_variables[_segment1_operator0_delta_a_field_variables_index_pointer + 2]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      
      // UNVECTORISABLE
      // This code copies the increments for the components back into the vectors themselves.
      rho = drho_dt * _step;
      NR = dNR_dt * _step;
      J = dJ_dt * _step;
      // Increment index pointers for vectors in field segment1_operator0_looping_field (or having the same dimensions)
      _mn_variables_index_pointer += 1 * _mn_variables_ncomponents;
      _segment1_operator0_delta_a_field_variables_index_pointer += 1 * _segment1_operator0_delta_a_field_variables_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  #undef rho
  #undef NR
  #undef J
  #undef drho_dt
  #undef dNR_dt
  #undef dJ_dt
}

// ********************************************************
//   output function implementations
void _write_output()
{
  _LOG(_SIMULATION_LOG_LEVEL, "Generating output for org-pol-lat\n");
  
  
  char *_xsilFilename = (char*)malloc(256);
  snprintf(_xsilFilename, 256, "%s.xsil", ("org-pol-lat" + gsArgsAndValues).c_str());
  
  FILE* _outfile = _open_xsil_file(_xsilFilename);
  
  if (_outfile) {
    _write_xsil_header(_outfile);
    char _dataFilename[200];
    snprintf(_dataFilename, 200, "%s.h5", ("org-pol-lat" + gsArgsAndValues).c_str());
    
    H5Fclose(H5Fcreate(_dataFilename, H5F_ACC_TRUNC, H5P_DEFAULT, H5P_DEFAULT));
  }
  _mg0_write_out(_outfile);
  
  _write_xsil_footer(_outfile);
  _close_xsil_file(_outfile);
  free(_xsilFilename);
  _xsilFilename = NULL;
  _outfile = NULL;
  
}


FILE* _open_xsil_file(const char* _filename)
{
  
  FILE* fp = fopen(_filename, "w");
  
  if (fp == NULL)
    // _LOG will cause the simulation to exit
    _LOG(_ERROR_LOG_LEVEL, "Unable to open output file '%s'.\n"
                           "Exiting.\n", _filename);
  
  return fp;
}

void _close_xsil_file(FILE*& fp)
{
  if (fp)
    fclose(fp);
  fp = NULL;
  
}

void _write_xsil_header(FILE* fp)
{
  if (!fp)
    return;
  fprintf(fp, "<?xml version=\"1.0\" ?><simulation xmds-version=\"2\">\n");
  fprintf(fp, "  <name>org-pol-lat</name>\n");
  fprintf(fp, "  <author>Thomas Sturges</author>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <features>\n");
  fprintf(fp, "    <validation kind=\"run-time\"/>\n");
  fprintf(fp, "    <globals>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "      real Kron(int m, int n) {\n");
  fprintf(fp, "        return (m == n) ? 1 : 0;\n");
  fprintf(fp, "      }\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </globals>\n");
  fprintf(fp, "    <arguments>\n");
  fprintf(fp, "        <argument name=\"gammaR\" type=\"real\" default_value=\"0.7\"/>\n");
  fprintf(fp, "        <argument name=\"gammaC\" type=\"real\" default_value=\"4\"/>\n");
  fprintf(fp, "        <argument name=\"gammaV\" type=\"real\" default_value=\"2.9\"/>\n");
  fprintf(fp, "        <argument name=\"P0\" type=\"real\" default_value=\"30.\"/>\n");
  fprintf(fp, "        <argument name=\"g\" type=\"real\" default_value=\"0.5\"/>\n");
  fprintf(fp, "        <argument name=\"omegaR\" type=\"real\" default_value=\"2720\"/>\n");
  fprintf(fp, "        <argument name=\"omegaC\" type=\"real\" default_value=\"2526\"/>\n");
  fprintf(fp, "        <argument name=\"omegaV\" type=\"real\" default_value=\"194\"/>\n");
  fprintf(fp, "        <argument name=\"Omega0\" type=\"real\" default_value=\"33\"/>\n");
  fprintf(fp, "        <argument name=\"OmegaDiff\" type=\"real\" default_value=\"7\"/>\n");
  fprintf(fp, "        <argument name=\"M\" type=\"int\" default_value=\"40\"/>\n");
  fprintf(fp, "        <argument name=\"sigmaOmega\" type=\"real\" default_value=\"0 * Omega0\"/>\n");
  fprintf(fp, "        <argument name=\"sigmadelta\" type=\"real\" default_value=\"0* Omega0\"/>\n");
  fprintf(fp, "        <argument name=\"Gamma\" type=\"real\" default_value=\"gammaR + gammaC + gammaV\"/>\n");
  fprintf(fp, "        <argument name=\"hbar\" type=\"real\" default_value=\"0.6582\"/>\n");
  fprintf(fp, "    </arguments>\n");
  fprintf(fp, "  </features>\n");
  fprintf(fp, "  \n");
  fprintf(fp, "  <geometry>\n");
  fprintf(fp, "    <propagation_dimension> t </propagation_dimension>\n");
  fprintf(fp, "    <transverse_dimensions>\n");
  fprintf(fp, "      <dimension name=\"m\" type=\"integer\" lattice=\"M\" domain=\"(1,M)\"/>\n");
  fprintf(fp, "      <dimension name=\"n\" type=\"integer\" lattice=\"M\" domain=\"(1,M)\"/>\n");
  fprintf(fp, "    </transverse_dimensions>\n");
  fprintf(fp, "  </geometry>\n");
  fprintf(fp, "  \n");
  fprintf(fp, "  <vector name=\"variables\" type=\"complex\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      rho NR J\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "      rho(m => m, n => n) = 0.;\n");
  fprintf(fp, "      NR(m => m) = 0.;\n");
  fprintf(fp, "      J(m => m, n => n) = 0.;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <noise_vector name=\"TheOmegaNoise\" dimensions=\"m n\" kind=\"gauss\" type=\"real\" method=\"posix\">\n");
  fprintf(fp, "    <components>OmegaNoise</components>\n");
  fprintf(fp, "  </noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <noise_vector name=\"OnSiteNoise\" dimensions=\"m\" kind=\"gauss\" type=\"real\" method=\"posix\">\n");
  fprintf(fp, "    <components>onsiteNoise</components>\n");
  fprintf(fp, "  </noise_vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <vector name=\"OmegaVec\" type=\"real\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      Omega\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <dependencies>TheOmegaNoise</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "      Omega(m => m, n => n) = (abs(m - n) == 1) ? Omega0 - OmegaDiff * pow(-1, max(m,n)) + (sigmaOmega / sqrt(2)) * (OmegaNoise(m => m, n => n) + OmegaNoise(m => n, n => m)): 0;\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <vector name=\"deltaVec\" type=\"real\">\n");
  fprintf(fp, "    <components>\n");
  fprintf(fp, "      delta\n");
  fprintf(fp, "    </components>\n");
  fprintf(fp, "    <initialisation>\n");
  fprintf(fp, "      <dependencies>OnSiteNoise</dependencies>\n");
  fprintf(fp, "      <![CDATA[\n");
  fprintf(fp, "      delta(m => m) = omegaR - (omegaC + sigmadelta * onsiteNoise(m => m) + omegaV);\n");
  fprintf(fp, "      ]]>\n");
  fprintf(fp, "    </initialisation>\n");
  fprintf(fp, "  </vector>\n");
  fprintf(fp, "\n");
  fprintf(fp, "  <sequence>\n");
  fprintf(fp, "    <integrate algorithm=\"RK4\" interval=\"5\" tolerance=\"1.0e-15\" steps=\"50000\">\n");
  fprintf(fp, "      <samples>200</samples>\n");
  fprintf(fp, "      <operators>\n");
  fprintf(fp, "        <integration_vectors>variables</integration_vectors>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "        complex sum1 = 0.;\n");
  fprintf(fp, "        complex sum2 = 0.;\n");
  fprintf(fp, "        complex rhomn = rho(m => m, n => n);\n");
  fprintf(fp, "        complex rhonm = rho(m => n, n => m);\n");
  fprintf(fp, "        complex rhomm = rho(m => m, n => m);\n");
  fprintf(fp, "        complex Jmn = J(m => m, n => n);\n");
  fprintf(fp, "        complex Jnm = J(m => n, n => m);\n");
  fprintf(fp, "        complex Jmm = J(m => m, n => m);\n");
  fprintf(fp, "        complex NRm = NR(m => m);\n");
  fprintf(fp, "        complex NRn = NR(m => n);\n");
  fprintf(fp, "        real pump = (m == M / 2) ? P0 : 0;\n");
  fprintf(fp, "        for (int i = 1; i <= M; ++i) {\n");
  fprintf(fp, "          real Omi = Omega(m => m, n => i);\n");
  fprintf(fp, "          real Oni = Omega(m => n, n => i);\n");
  fprintf(fp, "          sum1 += Omi * conj(rho(m => n, n => i)) - Oni * rho(m => m, n => i);\n");
  fprintf(fp, "          sum2 += Oni * J(m => m, n => i);\n");
  fprintf(fp, "        }\n");
  fprintf(fp, "        drho_dt(m => m, n => n) = (1 / hbar) * (-gammaC * rhomn + i * g * (conj(Jmn) - Jnm) + i * sum1);\n");
  fprintf(fp, "        dNR_dt(m => m) = (1 / hbar) * (-gammaR * NRm + pump - i * g * (conj(Jmm) - Jmm));\n");
  fprintf(fp, "        dJ_dt(m => m, n => n) = (1 / hbar) * (-(i * delta(m => n) + Gamma / 2) * Jmn + i * g * NRm * (Kron(m,n) + rhonm) + i * sum2);\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "        <dependencies>OmegaVec deltaVec</dependencies>\n");
  fprintf(fp, "      </operators>\n");
  fprintf(fp, "    </integrate>\n");
  fprintf(fp, "  </sequence>\n");
  fprintf(fp, "  \n");
  fprintf(fp, "  <output format=\"hdf5\" filename=\"org-pol-lat\">\n");
  fprintf(fp, "      <sampling_group basis=\"m n\" initial_sample=\"yes\">\n");
  fprintf(fp, "        <moments>rhoReOut</moments>\n");
  fprintf(fp, "        <dependencies>variables</dependencies>\n");
  fprintf(fp, "        <![CDATA[\n");
  fprintf(fp, "          rhoReOut = rho.Re();\n");
  fprintf(fp, "        ]]>\n");
  fprintf(fp, "      </sampling_group>\n");
  fprintf(fp, "  </output>\n");
  
  fprintf(fp, "\n<info>\n");
  fprintf(fp, "Script compiled with XMDS2 version 3.0.0 \"Release the Kraken\" (r3117)\n");
  fprintf(fp, "See http://www.xmds.org for more information.\n");
  fprintf(fp, "\nVariables that can be specified on the command line:\n");
  
  fprintf(fp, "  Command line argument gammaR = %e\n", gammaR);
  
  fprintf(fp, "  Command line argument gammaC = %e\n", gammaC);
  
  fprintf(fp, "  Command line argument gammaV = %e\n", gammaV);
  
  fprintf(fp, "  Command line argument P0 = %e\n", P0);
  
  fprintf(fp, "  Command line argument g = %e\n", g);
  
  fprintf(fp, "  Command line argument omegaR = %e\n", omegaR);
  
  fprintf(fp, "  Command line argument omegaC = %e\n", omegaC);
  
  fprintf(fp, "  Command line argument omegaV = %e\n", omegaV);
  
  fprintf(fp, "  Command line argument Omega0 = %e\n", Omega0);
  
  fprintf(fp, "  Command line argument OmegaDiff = %e\n", OmegaDiff);
  
  fprintf(fp, "  Command line argument M = %i\n", M);
  
  fprintf(fp, "  Command line argument sigmaOmega = %e\n", sigmaOmega);
  
  fprintf(fp, "  Command line argument sigmadelta = %e\n", sigmadelta);
  
  fprintf(fp, "  Command line argument Gamma = %e\n", Gamma);
  
  fprintf(fp, "  Command line argument hbar = %e\n", hbar);
  fprintf(fp, "\nNo seeds were provided for noise vector 'TheOmegaNoise'. The seeds generated were:\n");
  fprintf(fp, "    %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", _gen_TheOmegaNoise_seeds[0], _gen_TheOmegaNoise_seeds[1], _gen_TheOmegaNoise_seeds[2], _gen_TheOmegaNoise_seeds[3], _gen_TheOmegaNoise_seeds[4], _gen_TheOmegaNoise_seeds[5], _gen_TheOmegaNoise_seeds[6], _gen_TheOmegaNoise_seeds[7], _gen_TheOmegaNoise_seeds[8], _gen_TheOmegaNoise_seeds[9]);
  
  fprintf(fp, "\nNo seeds were provided for noise vector 'OnSiteNoise'. The seeds generated were:\n");
  fprintf(fp, "    %u, %u, %u, %u, %u, %u, %u, %u, %u, %u\n", _gen_OnSiteNoise_seeds[0], _gen_OnSiteNoise_seeds[1], _gen_OnSiteNoise_seeds[2], _gen_OnSiteNoise_seeds[3], _gen_OnSiteNoise_seeds[4], _gen_OnSiteNoise_seeds[5], _gen_OnSiteNoise_seeds[6], _gen_OnSiteNoise_seeds[7], _gen_OnSiteNoise_seeds[8], _gen_OnSiteNoise_seeds[9]);
  fprintf(fp, "</info>\n");
  
}

// In addition to writing the footer (if 'fp' is not NULL)
// this function closes the fp file pointer.
void _write_xsil_footer(FILE* fp)
{
  if (fp) {
    fprintf(fp, "</simulation>\n");
  }
}

// ********************************************************
//   moment group 0 function implementations
void _mg0_sample()
{
  
  long _mn_variables_index_pointer = 0;
  #define rho _active_mn_variables[_mn_variables_index_pointer + 0]
  #define NR _active_mn_variables[_mn_variables_index_pointer + 1]
  #define J _active_mn_variables[_mn_variables_index_pointer + 2]
  long _mg0_output_raw_index_pointer = 0;
  #define rhoReOut _active_mg0_output_raw[_mg0_output_raw_index_pointer + 0]
  #define m _m[_index_m + 0]
  #define dm (_dm * (1.0))
  
  for (long _index_m = 0; _index_m < _lattice_m; _index_m++) {
    #define n _n[_index_n + 0]
    #define dn (_dn * (1.0))
    
    for (long _index_n = 0; _index_n < _lattice_n; _index_n++) {
      // Set index pointers explicitly for (some) vectors
      _mg0_output_raw_index_pointer = ( 0
         + _mg0_output_index_t  * _lattice_m * _lattice_n
         + _index_m * _lattice_n
         + _index_n * 1 ) * _mg0_output_raw_ncomponents;
      #define _SAMPLE_COMPLEX(variable) \
                variable ## R = variable.Re(); variable ## I = variable.Im();
      
      // *************** Sampling code ****************
      #line 123 "org-pol-lat.xmds"
      
      rhoReOut = rho.Re();
      
      #line 1653 "org-pol-lat.cc"
      // **********************************************
      
      #undef _SAMPLE_COMPLEX
      // Increment index pointers for vectors in field mg0_sampling (or having the same dimensions)
      _mn_variables_index_pointer += 1 * _mn_variables_ncomponents;
      
    }
    #undef n
    #undef dn
  }
  #undef m
  #undef dm
  #undef rho
  #undef NR
  #undef J
  #undef rhoReOut
  
  _mg0_output_t[0 + _mg0_output_index_t++] = t;
  
  _LOG(_SAMPLE_LOG_LEVEL, "Sampled field (for moment group #1) at t = %e\n", t);
  
}


void _mg0_process()
{
  // No post processing needs to be done
}


void _mg0_write_out(FILE* _outfile)
{
  
  if (_outfile) {
    fprintf(_outfile, "\n");
    fprintf(_outfile, "<XSIL Name=\"moment_group_1\">\n");
    fprintf(_outfile, "  <Param Name=\"n_independent\">3</Param>\n");
    fprintf(_outfile, "  <Array Name=\"variables\" Type=\"Text\">\n");
    fprintf(_outfile, "    <Dim>4</Dim>\n");
    fprintf(_outfile, "    <Stream><Metalink Format=\"Text\" Delimiter=\" \\n\"/>\n");
    fprintf(_outfile, "t m n rhoReOut \n");
    fprintf(_outfile, "    </Stream>\n");
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "  <Array Name=\"data\" Type=\"double\">\n");
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _mg0_output_lattice_t);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_m);
    fprintf(_outfile, "    <Dim>%i</Dim>\n", _lattice_n);
    fprintf(_outfile, "    <Dim>4</Dim>\n");
  }
  
  
  char _h5Filename[200];
  snprintf(_h5Filename, 200, "%s.h5", ("org-pol-lat" + gsArgsAndValues).c_str());
  
  /* Open the file */
  hid_t hdf5_file = H5Fopen(_h5Filename, H5F_ACC_RDWR, H5P_DEFAULT);
  if (hdf5_file < 0) {
    _LOG(_WARNING_LOG_LEVEL, "Failed to open HDF5 file '%s', will try to create it.", _h5Filename);
    hdf5_file = H5Fcreate(_h5Filename, H5F_ACC_EXCL, H5P_DEFAULT, H5P_DEFAULT);
    if (hdf5_file < 0) {
      _LOG(_ERROR_LOG_LEVEL, "Failed to create HDF5 file '%s'. Bailing.", _h5Filename);
    }
  }
  
  /* Create the group for this data */
  hid_t group;
  if (!H5Lexists(hdf5_file, "/1", H5P_DEFAULT))
    group = H5Gcreate(hdf5_file, "/1", H5P_DEFAULT);
  else
    group = H5Gopen(hdf5_file, "/1");
  
  if (_outfile) {
    fprintf(_outfile, "    <Stream><Metalink Format=\"HDF5\" Type=\"Remote\" Group=\"/1\"/>\n");
    fprintf(_outfile, "%s.h5\n", ("org-pol-lat" + gsArgsAndValues).c_str());
    fprintf(_outfile, "    </Stream>\n");
  }
  
  /* Create the coordinate data sets */
  hsize_t coordinate_length;
  hid_t coordinate_dataspace;
  coordinate_length = _mg0_output_lattice_t;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_t;
  if (!H5Lexists(hdf5_file, "/1/t", H5P_DEFAULT))
    dataset_t = H5Dcreate(hdf5_file, "/1/t", H5T_NATIVE_REAL, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_t = H5Dopen(hdf5_file, "/1/t");
  H5Dwrite(dataset_t, H5T_NATIVE_REAL, H5S_ALL, H5S_ALL, H5P_DEFAULT, _mg0_output_t);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_t, "t");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_m;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_m;
  if (!H5Lexists(hdf5_file, "/1/m", H5P_DEFAULT))
    dataset_m = H5Dcreate(hdf5_file, "/1/m", H5T_NATIVE_LONG, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_m = H5Dopen(hdf5_file, "/1/m");
  H5Dwrite(dataset_m, H5T_NATIVE_LONG, H5S_ALL, H5S_ALL, H5P_DEFAULT, _m);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_m, "m");
  #endif
  
  H5Sclose(coordinate_dataspace);
  coordinate_length = _lattice_n;
  coordinate_dataspace = H5Screate_simple(1, &coordinate_length, NULL);
  hid_t dataset_n;
  if (!H5Lexists(hdf5_file, "/1/n", H5P_DEFAULT))
    dataset_n = H5Dcreate(hdf5_file, "/1/n", H5T_NATIVE_LONG, coordinate_dataspace, H5P_DEFAULT);
  else
    dataset_n = H5Dopen(hdf5_file, "/1/n");
  H5Dwrite(dataset_n, H5T_NATIVE_LONG, H5S_ALL, H5S_ALL, H5P_DEFAULT, _n);
  #if defined(HAVE_HDF5_HL)
    H5DSset_scale(dataset_n, "n");
  #endif
  
  H5Sclose(coordinate_dataspace);
  
  hsize_t file_dims[] = {_mg0_output_lattice_t, _lattice_m, _lattice_n};
  hid_t file_dataspace = H5Screate_simple(3, file_dims, NULL);
  
  hid_t dataset_rhoReOut;
  if (!H5Lexists(hdf5_file, "/1/rhoReOut", H5P_DEFAULT))
    dataset_rhoReOut = H5Dcreate(hdf5_file, "/1/rhoReOut", H5T_NATIVE_REAL, file_dataspace, H5P_DEFAULT);
  else
    dataset_rhoReOut = H5Dopen(hdf5_file, "/1/rhoReOut");
  #if defined(HAVE_HDF5_HL)
    H5DSattach_scale(dataset_rhoReOut, dataset_t, 0);
    H5DSattach_scale(dataset_rhoReOut, dataset_m, 1);
    H5DSattach_scale(dataset_rhoReOut, dataset_n, 2);
  #endif
  H5Dclose(dataset_t);
  H5Dclose(dataset_m);
  H5Dclose(dataset_n);
  
  
  if ((_mg0_output_lattice_t * _lattice_m * _lattice_n)) {
    /* Create the data space */
    hsize_t file_start[3] = {(unsigned long long int)0, (unsigned long long int)0, (unsigned long long int)0};
    hsize_t mem_dims[4] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_m, (unsigned long long int)_lattice_n, (unsigned long long int)1};
    hsize_t mem_start[4] = {0, 0, 0, 0};
    hsize_t mem_stride[4] = {1, 1, 1, 1};
    hsize_t mem_count[4] = {(unsigned long long int)_mg0_output_lattice_t, (unsigned long long int)_lattice_m, (unsigned long long int)_lattice_n, (unsigned long long int)1};
    
    
    hid_t mem_dataspace;
    mem_dims[3] = 1;
    mem_dataspace = H5Screate_simple(4, mem_dims, NULL);
    mem_stride[3] = 1;
    
    // Select hyperslabs of memory and file data spaces for data transfer operation
    mem_start[3] = 0;
    H5Sselect_hyperslab(mem_dataspace, H5S_SELECT_SET, mem_start, mem_stride, mem_count, NULL);
    H5Sselect_hyperslab(file_dataspace, H5S_SELECT_SET, file_start, mem_stride, mem_count, NULL);
    
    if (dataset_rhoReOut)
      H5Dwrite(dataset_rhoReOut, H5T_NATIVE_REAL, mem_dataspace, file_dataspace, H5P_DEFAULT, _active_mg0_output_raw);
    
    H5Sclose(mem_dataspace);
  }
  
  
  H5Dclose(dataset_rhoReOut);
  
  H5Sclose(file_dataspace);
  H5Gclose(group);
  H5Fclose(hdf5_file);
  
  
  if (_outfile) {
    fprintf(_outfile, "  </Array>\n");
    fprintf(_outfile, "</XSIL>\n");
  }
}

// ********************************************************
//   field mg0_output function implementations
// initialisation for vector raw
void _mg0_output_raw_initialise()
{
  
  bzero(_active_mg0_output_raw, sizeof(real) * _mg0_output_raw_alloc_size);
}

